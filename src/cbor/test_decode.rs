use cbor::decode::*;

// First test all the basic types

fn test_decoder(bytes: &Vec<u8>, expected: &'static str) {
    assert_eq!(decode_element(bytes).unwrap(), expected);
}

#[test]
fn test_integer() {
    let bytes: Vec<u8> = vec![0x00];
    test_decoder(&bytes, "0");

    let bytes = vec![0x01];
    test_decoder(&bytes, "1");

    let bytes = vec![0x0A];
    test_decoder(&bytes, "10");

    let bytes = vec![0x17];
    test_decoder(&bytes, "23");

    let bytes = vec![0x18, 0x18];
    test_decoder(&bytes, "24");

    let bytes = vec![0x18, 0x19];
    test_decoder(&bytes, "25");

    let bytes = vec![0x18, 0x64];
    test_decoder(&bytes, "100");

    let bytes = vec![0x19, 0x03, 0xe8];
    test_decoder(&bytes, "1000");

    let bytes = vec![0x1a, 0x00, 0x0f, 0x42, 0x40];
    test_decoder(&bytes, "1000000");

    let bytes = vec![0x1b, 0x00, 0x00, 0x00, 0xe8, 0xd4, 0xa5, 0x10, 0x00];
    test_decoder(&bytes, "1000000000000");

    let bytes = vec![0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
    test_decoder(&bytes, "18446744073709551615");
}

#[test]
fn test_signed_integer() {
    let bytes: Vec<u8> = vec![0x20];
    test_decoder(&bytes, "-1");

    let bytes = vec![0x29];
    test_decoder(&bytes, "-10");

    let bytes = vec![0x38, 0x63];
    test_decoder(&bytes, "-100");

    let bytes = vec![0x39, 0x03, 0xe7];
    test_decoder(&bytes, "-1000");

    let bytes = vec![0x39, 0x27, 0x0F];
    test_decoder(&bytes, "-10000");

    let bytes = vec![0x3A, 0x00, 0x01, 0x86, 0x9F];
    test_decoder(&bytes, "-100000");

    let bytes = vec![0x3B, 0x00, 0x00, 0x00, 0xE8, 0xD4, 0xA5, 0x0F, 0xFF];
    test_decoder(&bytes, "-1000000000000");
}

#[test]
#[should_panic]
fn test_panics_for_now() {
    let bytes: Vec<u8> = vec![0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                              0xff];
    test_decoder(&bytes, "-18446744073709551616");

    let bytes: Vec<u8> = vec![0xc3, 0x49, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x00];
    test_decoder(&bytes, "-18446744073709551617");

    let bytes = vec![0xc2, 0x49, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00];
    test_decoder(&bytes, "18446744073709551616");
}

#[test]
fn test_byte_strings() {
    let bytes: Vec<u8> = vec![0x40];
    test_decoder(&bytes, "");

    let bytes: Vec<u8> = vec![0x44, 0x01, 0x02, 0x03, 0x04];
    test_decoder(&bytes, "01020304");

    let bytes: Vec<u8> = vec![0x49, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09];
    test_decoder(&bytes, "010203040506070809");

    let bytes: Vec<u8> = vec![0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                              0x10];
    test_decoder(&bytes, "0102030405060708090A0B0C0D0E0F10");

    let bytes: Vec<u8> = vec![0x54, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                              0x10, 0x20, 0x30, 0x40, 0x50];
    test_decoder(&bytes, "0102030405060708090A0B0C0D0E0F1020304050");

    let bytes: Vec<u8> = vec![0x55, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                              0x10, 0x20, 0x30, 0x40, 0x50, 0x60];
    test_decoder(&bytes, "0102030405060708090A0B0C0D0E0F102030405060");

    let bytes: Vec<u8> = vec![0x56, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                              0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70];
    test_decoder(&bytes, "0102030405060708090A0B0C0D0E0F10203040506070");

    let bytes: Vec<u8> = vec![0x57, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                              0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80];
    test_decoder(&bytes, "0102030405060708090A0B0C0D0E0F1020304050607080");

    let bytes: Vec<u8> = vec![0x58, 0x18, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                              0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
                              0x0f, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
                              0x80, 0x90];
    test_decoder(&bytes, "0102030405060708090A0B0C0D0E0F102030405060708090");

    let bytes: Vec<u8> = vec![0x59, 0x01, 0x0E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                              0xFF];
    test_decoder(&bytes, concat!(
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"#,
        r#"FFFFFFFFFFFF"#));
}

#[test]
fn test_utf8_strings() {
    let bytes: Vec<u8> = vec![0x60];
    test_decoder(&bytes, "");

    let bytes: Vec<u8> = vec![0x61, 0x61];
    test_decoder(&bytes, "a");

    let bytes: Vec<u8> = vec![0x64, 0x49, 0x45, 0x54, 0x46];
    test_decoder(&bytes, "IETF");

    let bytes: Vec<u8> = vec![0x62, 0x22, 0x5c];
    test_decoder(&bytes, "\"\\");

    let bytes: Vec<u8> = vec![0x63, 0xe6, 0xb0, 0xb4];
    test_decoder(&bytes, "Ê∞¥");

    let bytes: Vec<u8> = vec![0x64, 0xf0, 0x90, 0x85, 0x91];
    test_decoder(&bytes, "êÖë");

    let bytes: Vec<u8> = vec![0x78, 0x1E, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
                              0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
                              0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
                              0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41];
    test_decoder(&bytes, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

    // XXX: this could use longer test cases.
}

#[test]
fn test_arrays() {
    let bytes: Vec<u8> = vec![0x80];
    test_decoder(&bytes, "[]");

    let bytes: Vec<u8> = vec![0x83, 0x01, 0x02, 0x03];
    test_decoder(&bytes, "[1, 2, 3]");

    let bytes: Vec<u8> = vec![0x83, 0x01, 0x82, 0x02, 0x03, 0x82, 0x04, 0x05];
    test_decoder(&bytes, "[1, [2, 3], [4, 5]]");

    let bytes: Vec<u8> = vec![0x98, 0x1A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                              0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
                              0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
                              0x17, 0x18, 0x18, 0x18, 0x19, 0x82, 0x81, 0x81,
                              0x81, 0x05, 0x81, 0x1A, 0x49, 0x96, 0x02, 0xD2];
    test_decoder(&bytes,
        "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, [[[[5]]], [1234567890]]]");
}

#[test]
fn test_maps() {
    let bytes: Vec<u8> = vec![0xa0];
    test_decoder(&bytes, "{}");

    let bytes: Vec<u8> = vec![0xa2, 0x01, 0x02, 0x03, 0x04];
    test_decoder(&bytes, "{1: 2, 3: 4}");

    let bytes: Vec<u8> = vec![0xa2, 0x61, 0x61, 0x01, 0x61, 0x62, 0x82, 0x02, 0x03];
    test_decoder(&bytes, "{a: 1, b: [2, 3]}");

    let bytes: Vec<u8> = vec![0x82, 0x61, 0x61, 0xa1, 0x61, 0x62, 0x61, 0x63];
    test_decoder(&bytes, "[a, {b: c}]");

    let bytes: Vec<u8> = vec![0xa5, 0x61, 0x61, 0x61, 0x41, 0x61, 0x62, 0x61,
                              0x42, 0x61, 0x63, 0x61, 0x43, 0x61, 0x64, 0x61,
                              0x44, 0x61, 0x65, 0x61, 0x45];
    test_decoder(&bytes, "{a: A, b: B, c: C, d: D, e: E}");
}
